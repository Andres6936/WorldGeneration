"use strict";

let randomSeed = 6;

function random() {
  let x = Math.sin(randomSeed) * 10000;
  randomSeed = (randomSeed + Math.E) % 1e8;
  return x - Math.floor(x);
}

function spread(range) {
  return range * (random() - 0.5);
}

/**
 * @param {number} x
 * @param {number} y
 */
function coord2ind([x, y], width) {
  return [Math.floor(x) + Math.floor(y * width)];
}

/**
 * @returns {CanvasRenderingContext2D}
 */
function context2d(canvas) {
  return canvas.getContext("2d");
}

/**
 * Creates canvas of the required size and returns it and it's 2d context.
 * @param {number} width
 * @param {number} height
 * @returns {{canvas:HTMLCanvasElement, ctx:CanvasRenderingContext2D}}
 */
function createCanvasCtx(width, height) {
  let canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  let ctx = context2d(canvas);
  return { canvas, ctx };
}

/**
 * Returns alpha channel of the image as numbers in 0-255 range.
 * @param {HTMLCanvasElement} ctx
 * @returns {values:Float32Array[]}
 */
function image2alpha(canvas) {
  let ctx = context2d(canvas);
  let idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let data = idata.data;
  let values = new Float32Array(data.length / 4);
  for (let i = 0; i < data.length; i++) values[i] = data[i * 4 + 3] / 255;

  return values;
}

/**
 * Gradient noise generated by throwing ellipses at the plain.
 * @param {number} width
 * @param {number} height
 */
function gradientNoise(
  width,
  height,
  points = 5000,
  radius = 100,
  alpha = 0.01,
  gradientCircles = true
) {
  let { canvas, ctx } = createCanvasCtx(width, height);

  if (gradientCircles) {
    let g = ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
    g.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
    g.addColorStop(1, `rgba(255, 255, 255, 0)`);

    ctx.fillStyle = g;
  } else {
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
  }

  for (let i = 0; i < points; i++) {
    let points = [...Array(3)].map(() => random());

    let [x, y] = [points[0] * width, points[1] * height];
    let r = Math.pow(points[2], 2) * radius;

    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(random() * Math.PI);
    ctx.scale(r * (0.5 + random()), r * (0.5 + random()));
    ctx.beginPath();
    ctx.arc(0, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  return canvas;
}

function addFilter(srcCanvas, filter) {
  let { canvas, ctx } = createCanvasCtx(srcCanvas.width, srcCanvas.height);
  ctx.filter = filter;
  ctx.drawImage(srcCanvas, 0, 0);
  return canvas;
}

/**
 * Monte-Carlo approximation of the quantile
 * @param {number[]} values
 * @param {number} picks
 * @param {number} level
 */
function approximateQuantile(values, level = 0.5, picks = 1000) {
  let l = values.length;
  let picked = [...Array(picks)].map(() => values[Math.floor(random() * l)]);
  picked = picked.sort();
  return picked[Math.floor(level * picked.length)];
}

function normalizeValues(values, picks = 1000) {
  let l = values.length;
  let picked = [...Array(picks)].map(() => values[Math.floor(random() * l)]);
  let max = 0;
  for (let v of picked) if (v > max) max = v;
  return values.map((v) => v / max);
}

/**
 * @param {number} width
 * @param {number} height
 */
function generateMap({
  width,
  height,
  seed,
  seaRatio,
  flatness,
  noiseSmoothness,
  tectonicSmoothness,
  noiseFactor,
  crustFactor,
  tectonicFactor,
  averageTemperature,
  biomeScrambling,
  pangaea,
  erosion,
  riversShown,
  randomiseHumidity,
}) {
  randomSeed = seed;

  const mapSize = width * height;
  const mapDiagonal = Math.sqrt(width * width + height * height);

  console.time("noise");

  let noise = image2alpha(
    addFilter(
      gradientNoise(width, height, 3000, mapDiagonal * 0.15, 0.01),
      `blur(${noiseSmoothness}px)`
    )
  );
  let crust = image2alpha(
    addFilter(
      gradientNoise(width, height, 2000, mapDiagonal * 0.15, 0.03),
      `blur(${tectonicSmoothness}px)`
    )
  );
  console.timeEnd("noise");

  console.time("main");

  let tectonicMedian = approximateQuantile(crust, 0.5);

  let tectonic = crust.map(
    (v) => 0.2 / (Math.abs(tectonicMedian - v)+0.1) - 0.95 
  );

  let elevation = noise.map(
    (_, i) =>
      5 +
      noise[i] * noiseFactor +
      crust[i] * crustFactor +
      tectonic[i] * tectonicFactor +
      -pangaea *
        (Math.abs(i / mapSize - 0.5) + Math.abs((i % width) / width - 0.5))
  );

  console.timeEnd("main");

  console.time("normalize");

  elevation = normalizeValues(elevation);

  let seaLevel = approximateQuantile(elevation, seaRatio);

  elevation = elevation.map((v, i) =>
    v < seaLevel
      ? -Math.pow(1 - v / seaLevel, 0.4)
      : Math.pow(
          ((v - seaLevel) * (0.5 + tectonic[i] * 0.5)) / (1 - seaLevel),
          1 + 2 * flatness
        )
  );

  console.timeEnd("normalize");

  let wind = elevation.map(
    (h, i) =>
      Math.cos((Math.abs(0.5 - i / mapSize) * 4 + 0.85) * Math.PI) /
      (h<0?1:(1 + 10 * h * h))
  );

  console.time("windSmoothing");
  wind = image2alpha(
    addFilter(
      data2image(wind, width, (v) => [0, 0, 0, 127 * (v + 1)]),
      "blur(3px)"
    )
  ).map((v) => v * 2 - 1);
  console.timeEnd("windSmoothing");

  let rivers = generateRiversAndErosion({
    width,
    height,
    elevation,
    tectonic,
    erosion,
    riversShown,
  });

  let humidity = generateHumidity({ width, height, elevation, wind });

  if (randomiseHumidity) {
    humidity = humidity.map((v, i) =>
      Math.max(0, v + Math.sin(noise[i] * 50) / 10 - elevation[i] * 0.2)
    );
  }

  let temperature = elevation.map(
    (e, i) =>
      averageTemperature +
      35 -
      (120 * Math.abs(0.5 - i / mapSize)) / (0.7 + 0.6 * humidity[i]) -
      Math.max(0, e) * 30
  );

  humidity = humidity.map((w, i) => w * (1 + Math.atan(-temperature[i] / 100)));

  console.time("biome");
  let biome = temperature.map((t, i) => {
    let h = elevation[i];
    let b =
      biomeTable[
        Math.floor(
          Math.max(
            0,
            Math.min(
              humidity[i] *
                4.5 *
                (1 + biomeScrambling * Math.sin(noise[i] * 100)),
              5
            )
          )
        )
      ][Math.floor(Math.max(0, Math.min(t / 10 + 1, 3)))] || 0;
    if (b == TUNDRA && h > 0.5) b = MOUNTAIN;
    return b;
  });
  console.timeEnd("biome");

  console.time("photo");
  let photo = [...humidity].map((w, i) => {
    if (elevation[i] < 0)
      return [0, (1 + elevation[i]) * 55, (1 + elevation[i]) * 155, 255];
    else
      return [100 - w * 600 + temperature[i] * 5, 200 - w * 200, 130 - w * 300]
        .map(
          (v) =>
            (temperature[i] < 0 ? 255 : v) +
            -elevation[i] * 140 +
            25 *
              (2 +
                Math.atan(
                  ((elevation[i + width * (i>width*height/2?1:-1)] || 0) - 1 * elevation[i]) * 120
                ))
        )
        .concat([255]);
  });
  console.timeEnd("photo");

  return {
    elevation,
    noise,
    crust,
    tectonic,
    rivers,
    wind,
    noise,
    temperature,
    humidity,
    biome,
    photo,
  };
}

function generateHumidity({ width, height, elevation, wind }) {
  console.time("humidity");
  const mapDiagonal = Math.sqrt(width * width + height * height);

  let border = width / 2;

  let humidityImage = data2image(elevation, width, (v, i) => [
    0,
    0,
    0,
    v <= 0 ? 100 : 0,
  ]);
  let wetness = createCanvasCtx(width + border * 2, height + border * 2);

  wetness.ctx.beginPath();
  wetness.ctx.rect(border / 2, border / 2, width + border, height + border);
  wetness.ctx.lineWidth = border / 2;
  wetness.ctx.stroke();

  wetness.ctx.drawImage(humidityImage, width / 2, height / 2);

  wetness.ctx.filter = "opacity(16%)";
  const spotSize = mapDiagonal / 10;
  for (let i = 0; i < 1300; i++) {
    let start = [random() * width, random() * height];
    let windThere = wind[coord2ind(start, width)];
    let end = [
      start[0] - (windThere * (random() - 0.2) * width) / 6,
      start[1] + (Math.abs(windThere) * (random() - 0.5) * height) / 12,
    ];
    wetness.ctx.drawImage(
      wetness.canvas,
      end[0] + border,
      end[1] + border,
      spotSize,
      spotSize,
      start[0] + border,
      start[1] + border,
      spotSize,
      spotSize
    );
  }

  context2d(humidityImage).filter = "blur(5px)";
  context2d(humidityImage).drawImage(
    wetness.canvas,
    border,
    border,
    width,
    height,
    0,
    0,
    width,
    height
  );

  let humidity = image2alpha(humidityImage);

  console.timeEnd("humidity");

  return humidity;
}

function generateRiversAndErosion({
  width,
  height,
  elevation,
  humidity,
  tectonic,
  erosion,
  riversShown,
}) {
  console.time("rivers");

  let rivers = new Float32Array(width * height);

  let neighbors = [
    -1,
    1,
    -width,
    width,
    -1 - width,
    1 + width,
    1 - width,
    -1 + width,
  ];

  for (
    let streamIndex = 0;
    streamIndex < erosion + riversShown;
    streamIndex++
  ) {
    let current = Math.floor(random() * width * height);
    if (elevation[current] < random()) continue;

    if (humidity && humidity[current] < random()) continue;

    let limit = 10000;

    while (elevation[current] > -0.15 && limit-- > 0) {
      if (streamIndex > erosion) {
        rivers[current] += 1;
      }
      let currentValue = elevation[current];

      let lowestNeighbor = 0,
        lowestValue = 100;

      for (let neighborIndex = 0; neighborIndex < 8; neighborIndex++) {
        let neighborDelta = neighbors[neighborIndex];
        let value = elevation[current + neighborDelta];
        if (value <= lowestValue) {
          lowestNeighbor = current + neighborDelta;
          lowestValue = elevation[lowestNeighbor];
        }
      }

      if (lowestValue < currentValue) {
        elevation[current] -= (currentValue - lowestValue) / 10;
        if (rivers[lowestNeighbor]) limit -= 10;
        current = lowestNeighbor;
      } else {
        elevation[current] = lowestValue + 0.02 * (1 - elevation[current]);
      }
    }

    for(let i=0;i>10;i++){
      let erosionPoint = Math.floor(random() * width * height);
      let otherNeighbor = erosionPoint + neighbors[Math.floor(random()*8)];
      if(elevation[otherNeighbor] > elevation[erosionPoint])
        elevation[otherNeighbor] -= (elevation[otherNeighbor] - elevation[erosionPoint]) / 5 * (1 - tectonic[erosionPoint]);
    }

  }

  console.timeEnd("rivers");

  return rivers;
}

const DESERT = 1,
  GRASSLAND = 2,
  TUNDRA = 3,
  SAVANNA = 4,
  SHRUBLAND = 5,
  TAIGA = 6,
  DENSE_FOREST = 7,
  TEMPERATE_FOREST = 8,
  RAIN_FOREST = 9,
  SWAMP = 10,
  SNOW = 11,
  STEPPE = 12,
  CONIFEROUS_FOREST = 13,
  MOUNTAIN = 14,
  BEACH = 15;

// -> temperature V humidity
const biomeTable = [
  [TUNDRA, STEPPE, SAVANNA, DESERT],
  [TUNDRA, SHRUBLAND, GRASSLAND, GRASSLAND],
  [SNOW, SHRUBLAND, GRASSLAND, TEMPERATE_FOREST],
  [SNOW, CONIFEROUS_FOREST, TEMPERATE_FOREST, TEMPERATE_FOREST],
  [TAIGA, CONIFEROUS_FOREST, DENSE_FOREST, DENSE_FOREST],
  [TAIGA, CONIFEROUS_FOREST, DENSE_FOREST, RAIN_FOREST],
];

const biomeNames = [
  "unknown",
  "desert",
  "grassland",
  "tundra",
  "savanna",
  "shrubland",
  "taiga",
  "tropical forest",
  "decidious forest",
  "rain forest",
  "swamp",
  "snow",
  "steppe",
  "coniferous forest",
  "mountain shrubland",
  "beach",
];

function mapToList(m) {
  let l = [];
  for (let k in m) {
    l[k] = m[k];
  }
  return l;
}

function colorFromRGBString(color) {
  let n = parseInt(color, 16);
  return [Math.floor(n / 65536), Math.floor(n / 256) % 256, n % 256, 256];
}

const contrastColors = mapToList({
  [DESERT]: "ffff00",
  [GRASSLAND]: "40ff40",
  [TUNDRA]: "c0c0a0",
  [SAVANNA]: "c0c000",
  [SHRUBLAND]: "a0d040",
  [TAIGA]: "006080",
  [DENSE_FOREST]: "008000",
  [TEMPERATE_FOREST]: "40a040",
  [RAIN_FOREST]: "006020",
  [SWAMP]: "808000",
  [SNOW]: "ffffff",
  [STEPPE]: "c0ffa0",
  [CONIFEROUS_FOREST]: "008080",
  [MOUNTAIN]: "c080c0",
  [BEACH]: "ffff80",
}).map(colorFromRGBString);

/**
 * Convert data to image according to callback function
 * @param {any[]} values
 * @param {number} width
 * @param {(v:number, i:number) => [number,number,number,number]} converter
 * @returns {HTMLCanvasElement}
 */

function data2image(values, width, converter) {
  let height = values.length / width;
  let { canvas, ctx } = createCanvasCtx(width, height);
  let idata = ctx.createImageData(width, height);
  for (let i = 0; i < values.length; i++) {
    idata.data.set(converter(values[i], i), i * 4);
  }
  ctx.putImageData(idata, 0, 0);
  return canvas;
}

/**
 * Returns elevation image with higher elevation being brighter
 */
function elevation2Image(
  { elevation, rivers },
  {
    discreteHeights = 10,
    terrainTypeColoring = false,
    hillRatio = 0.1,
    mountainRatio = 0.02,
  }
) {
  let hillElevation = approximateQuantile(elevation, 1 - hillRatio);
  let mountainElevation = approximateQuantile(elevation, 1 - mountainRatio);

  console.log("hill", hillElevation);
  console.log("mountain", mountainElevation);

  let green = true;

  return (v, i) => {
    if (rivers[i] && v > 0) {
      return [0, v * 400, 200, 255];
    }

    let level = discreteHeights
      ? Math.floor(v * discreteHeights) / discreteHeights
      : v;

    if (v > 0) {
      if (terrainTypeColoring)
        return v < hillElevation
          ? [32, 128, 32, 255]
          : v < mountainElevation
          ? [196, 196, 32, 255]
          : [128, 32, 0, 255];
      else
        return green
          ? [level * 300, level * 200 + 100, 50, 255]
          : [250 - level * 300, 200 - level * 300, 0, 255];
    } else {
      return [0, level * 60 + 60, level * 80 + 100, 255];
    }
  };
}

const SQUARE = 0,
  ODDR = 1,
  AXIAL = 2;

/**
 * Returns indices of the elementsthat lie on a different resolution grid
 * @param {number} width
 * @param {number} height
 * @param {number} scale - how lower new resolution is
 * @param {number} geometry - SQUARE/0 for square grid,
 * ODDR/1 returns a hex grid with even rows shifted 0.5 right and rows height being 0.75 of columns width,
 * AXIAL/2 returns a hex grid with row shifted left by 0.5 more with each row
 */
function rescaleCoordinates(width, height, scale, geometry) {
  let verticalScale = geometry == 0 ? scale : scale * 0.75;
  let columns = Math.floor(width / scale) * (geometry == AXIAL ? 2 : 1);
  let rows = Math.floor(height / verticalScale);

  let result = new Array(rows * columns);

  for (let row = 0; row < rows; row++) {
    let y = Math.floor((row + 0.5) * verticalScale);
    let startX = 0;
    if (geometry == AXIAL) startX = -scale * 0.5 * row;
    else if (geometry == ODDR) startX = row % 2 == 1 ? scale / 2 : 1;
    for (let column = 0; column < columns; column++) {
      let x = Math.floor(startX + column * scale);
      if(x>=0 && x<=width)
        result[row * columns + column] = y * width + x;
    }
  }
  console.log(rows, columns);
  return result;
}

/**
 * Returns canvas rescaled to the new size
 * @param {HTMLCanvasElement} source
 * @param {number} width
 * @param {number} height
 * @returns {HTMLCanvasElement}
 */
function rescaleImage(source, width, height) {
  let { canvas, ctx } = createCanvasCtx(width, height);
  ctx.drawImage(source, 0, 0, source.width, source.height, 0, 0, width, height);
  return canvas;
}

/**
 * Returns canvas that is a fragment of the source canvas
 * @param {HTMLCanvasElement} image
 * @param {number} left
 * @param {number} top
 * @param {number} width
 * @param {number} height
 */
function subImage(image, left, top, width, height) {
  let { canvas, ctx } = createCanvasCtx(width, height);
  ctx.drawImage(image, left, top, width, height, 0, 0, width, height);
  return canvas;
}

/**
 * Returns the list of relative indices of neighbors for even and odd lines in clockwork order.
 * @param {*} columns
 * @param {*} geometry - one of SQUARE, ODDR or AXIAL
 */ 
function createNeighborDeltas(columns, geometry) {
  let r;
  switch (geometry) {
    case SQUARE:
      r = [
        [0, -1],
        [1, -1],
        [1, 0],
        [1, 1],
        [0, 1],
        [-1, 1],
        [-1, 0],
        [-1, -1],
      ].map(([dx, dy]) => dy * columns + dx);
      return [r, r];
    case ODDR:
      return [
        [
          [0, -1],
          [1, 0],
          [0, 1],
          [-1, 1],
          [-1, 0],
          [-1, -1],
        ],
        [
          [1, -1],
          [1, 0],
          [1, 1],
          [0, 1],
          [-1, 0],
          [0, -1],
        ],
      ].map((n) => n.map(([dx, dy]) => dy * columns + dx));
    case AXIAL:
      r = [
        [0, -1],
        [1, 0],
        [1, 1],
        [0, 1],
        [-1, 0],
        [-1, -1],
      ].map(([dx, dy]) => dy * columns + dx);
      return [r, r];
  }
}

/**
 * Returns a matrix of rivers sizes and directions per cell
 * @param {number[]} heights
 * @param {number[]} neighborDeltas
 * @returns {number[]}
 */
function generatePrettyRivers(
  heights,
  probability,
  attempts,
  neighborDeltas
) {
  let hlen = heights.length;
  let courseAt = 0;
  let course = new Int32Array(100);
  let riverDepth = new Int32Array(hlen);
  let flowsTo = new Int32Array(hlen);
  for (let riveri = 0; riveri < attempts; riveri++) {
    let at = Math.floor(random() * hlen);
    if (heights[at] <= 0 || probability[at] < random()) continue;
    courseAt = 0;
    while (heights[at] > 0 && courseAt < 100) {
      let lowestNeighborDelta = neighborDeltas.reduce((a, b) =>
        heights[at + a] - riverDepth[at + a] <
        heights[at + b] - riverDepth[at + b]
          ? a
          : b
      );
      if (heights[at + lowestNeighborDelta] >= heights[at]) break;
      at = at + lowestNeighborDelta;
      course[courseAt++] = at;
    }
    if (courseAt > 2 && heights[at] <= 0) {
      for (let i = 0; i < courseAt; i++) {
        riverDepth[course[i]]++;
        flowsTo[course[i]] = course[i+1];
      }
    }
  }
  return {riverDepth, flowsTo};
}